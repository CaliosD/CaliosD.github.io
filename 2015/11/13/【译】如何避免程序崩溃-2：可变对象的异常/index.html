<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 【译】如何避免程序崩溃-2：可变对象的异常 · Calios' Eden</title><meta name="description" content="【译】如何避免程序崩溃-2：可变对象的异常 - Calios"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/img/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.calios.gq/atom.xml" title="Calios' Eden"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/img/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link active">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/calios1124" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/caliosd" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">【译】如何避免程序崩溃-2：可变对象的异常</h1><div class="post-info">2015年11月13日</div><div class="post-tags"><a href="/tags/iOS/" class="post-tag"> iOS</a><a href="/tags/译言/" class="post-tag"> 译言</a><a href="/tags/NotToCrashSeries/" class="post-tag"> NotToCrashSeries</a></div><div class="post-content"><p>原文链接：<a href="http://inessential.com/2015/05/16/how_not_to_crash_2_mutation_exceptions" target="_blank" rel="external">http://inessential.com/2015/05/16/how_not_to_crash_2_mutation_exceptions</a></p>
<hr>
<p>你从某处获取到一个集合并枚举它 —— 然后当你在改变这个集合的时候报错，因为它正在进行枚举。应用崩溃了。</p>
<p>你可以通过一个小技巧避免这种悲伤的命运：不要对可变的集合进行枚举操作。</p>
<h4 id="异议"><a href="#异议" class="headerlink" title="异议"></a>异议</h4><p>你可能持有某种合理的观点，说<em>真正</em>的答案是不要在对集合进行枚举的时候对可变的集合进行改变。你应该对于自己的应用有足够的了解，以便能够写出安全地对可变集合进行枚举的代码。</p>
<p>是的，你应该如此。你绝对应该如此。</p>
<p>然而：编写远离崩溃的代码就是在于消除疑点。就在于能够将错误的几率最小化，将未来的（由你或其他人带来的）改变引入崩溃的可能性最小化。</p>
<h4 id="可变集合不应该成为公有接口的一部分"><a href="#可变集合不应该成为公有接口的一部分" class="headerlink" title="可变集合不应该成为公有接口的一部分"></a>可变集合不应该成为公有接口的一部分</h4><p>一个对象拥有一个可变集合作为公有属性，这件事本来就应该尽量避免 —— 或者最好不要发生。可变集合应该被控制在对象内部。</p>
<p>（更进一步地说，公有的集合应该为只读。当然事实也并非总是如此。）</p>
<p>现在，它整体上可能是有一个公有集合，在内部又有一个可变的集合。想象一个跟踪operation的对象。它可能公有方法这么写：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">property</span><span class="title"> </span>(nonatomic, readonly) NSArray *<span class="keyword">operations</span>;</div></pre></td></tr></table></figure></p>
<p>内部私有方法这么写：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSMutableArray</span> *mutableOperations;</div><div class="line">- (<span class="built_in">NSArray</span> *)operations &#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">self</span>.mutableOperations;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这是完全合情合理的代码：因为mutableOperations是一个NSMutableArray，它又同时是一个NSArray。（我多年来都这么写。我对自己说：”Hey，我是个过来人了。我能<em>应付的了</em>。“但是我没有意识到的是，成熟的开发者是为了减少出错的可能而写代码。）</p>
<h4 id="被指定为不可变的属性应该名副其实"><a href="#被指定为不可变的属性应该名副其实" class="headerlink" title="被指定为不可变的属性应该名副其实"></a>被指定为不可变的属性应该名副其实</h4><p>在上面的例子中，你声明<code>operations</code>是一个在任何时候都可以安全枚举的数组。另一个人 —— 或者就是你自己 —— 在六个月之后看这段代码时，完全不会意识到你正在获取的可变数组，并<em>不能</em>足够安全地进行枚举。</p>
<p>这就是实现名副其实的解决方案：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSArray</span> *)operations &#123;</div><div class="line">  <span class="keyword">return</span> [<span class="keyword">self</span>.mutableOperations <span class="keyword">copy</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>（如果为了表达得更清晰，把属性声明为copy也不会有影响，但是我承认我不经常这么做。让API的使用者完全清晰地知道正在发生什么应该是有好处的。）</p>
<p>你可能会翻回去引用性能或者内存使用的问题或者二者皆有 —— 而我必须承认：我是一个性能的推崇者，我会在Instruments上花费超乎常理的时间，仅为了能够让代码快速运行、没有不合理的内存消耗。我从来没有发现这么做有任何问题。如果你的应用出现性能或者内存消耗的问题，可能是其他问题导致的，而不是这些copy。（尽管你可以考虑使用<code>@autoreleasepool</code>来让这些copy不留存那么长时间。）</p>
<p>copy一下吧。</p>
<h4 id="彩蛋：不要相信他们的谎言"><a href="#彩蛋：不要相信他们的谎言" class="headerlink" title="彩蛋：不要相信他们的谎言"></a>彩蛋：不要相信他们的谎言</h4><p>我最近解决了一个在枚举NSTextStorage layoutManager时可变量的问题：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span> *layoutManagers;</div></pre></td></tr></table></figure></p>
<p><em>显然</em> 枚举是安全的。它是一个NSArray，它声明自己是个copy。漂亮。枚举走起。</p>
<p>但是，它骗我。在调试器里，我发现它是一个NSMutableArray（__NSArrayM）—— 而且它根本就不是一个copy。它是NSTextStorage的名为<code>_layoutManagers</code>的实例变量，这个变量被声明为一个NSMutableArray。</p>
<p>而在我的枚举的block代码里面，触发了layoutManagers的改变，然后应用就崩溃了。</p>
<p>答案是：对layoutManagers的副本进行枚举。问题就解决了。</p>
<p>常言道：如果你从别人的代码中获取一个集合，对副本进行枚举总没坏处，防患于未然嘛。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2015/11/16/【译】如何避免程序崩溃-3：NSNotification/" class="prev">PREV</a><a href="/2015/11/12/【译】如何避免程序崩溃-1：KVO与手动绑定/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2017 <a href="http://www.calios.gq">Calios</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>