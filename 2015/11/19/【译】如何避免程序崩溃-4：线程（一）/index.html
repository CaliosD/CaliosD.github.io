<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 【译】如何避免程序崩溃 -4：线程（一） · Calios' Eden</title><meta name="description" content="【译】如何避免程序崩溃 -4：线程（一） - Calios"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.calios.gq/atom.xml" title="Calios' Eden"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/img/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/calios1124" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/caliosd" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">【译】如何避免程序崩溃 -4：线程（一）</h1><div class="post-info">2015年11月19日</div><div class="post-content"><p>原文链接：<a href="http://inessential.com/2015/05/22/how_not_to_crash_4_threading" title="http://inessential.com/2015/05/22/how_not_to_crash_4_threading" target="_blank" rel="external">http://inessential.com/2015/05/22/how_not_to_crash_4_threading</a></p>
<hr>
<p>有一个简单的规则：所有事情都在主线程上做。机器和设备如今都很快，你可以在主线程上做比你想象的多得多的事。</p>
<p>当你不必考虑并发的时候，那就是某种意义上的天堂了，因为并不存在并发的问题。</p>
<p>但是……</p>
<p>我是一个性能的推崇者。或者更贴切地说，我是个用户体验的推崇者，比反应迟钝更糟糕的是反应迟钝并且明显地阻塞在主线程。不要那么做。</p>
<p>我会讲解那件事。但是让我们先从主线程开始。</p>
<h4 id="主线程规则"><a href="#主线程规则" class="headerlink" title="主线程规则"></a>主线程规则</h4><p>我写的所有代码都希望运行在主线程上，并且除非特例，否则只运行在主线程上。（我们马上会讲到特例。）</p>
<p>这就解决了一堆的问题。比如说，我之前写过的一篇<a href="http://www.calios.gq/2015/11/16/%E3%80%90%E8%AF%91%E3%80%91%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E7%A8%8B%E5%BA%8F%E5%B4%A9%E6%BA%83-3%EF%BC%9ANSNotification/" title="http://www.calios.gq/2015/11/16/%E3%80%90%E8%AF%91%E3%80%91%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E7%A8%8B%E5%BA%8F%E5%B4%A9%E6%BA%83-3%EF%BC%9ANSNotification/">在dealloc中取消通知的注册</a>。有些人指出你不能保证dealloc在那个线程上被调用 —— 但是你实际上是可以的，对于任何运行在主线程上的给定对象，只在主线程上被引用。</p>
<p>这也就意味着，任何KVO的改变都会在主线程上传播，任何观察的对象都会运行在主线程上，同时等待来自主线程的通知。</p>
<p>不需要处理并发的好处简直是<em>巨大的</em>。我强烈建议你用这种方式写你整个应用，然后测试看是否有什么地方阻塞了主线程。如果没有，那就是完美了，你就可以结束战斗了。（当然，用合适的大量数据来测试。）</p>
<h4 id="生活在它们自己小圈子中的对象"><a href="#生活在它们自己小圈子中的对象" class="headerlink" title="生活在它们自己小圈子中的对象"></a>生活在它们自己小圈子中的对象</h4><p>如果 —— 只有如果 —— 当你发现主线程明显被阻塞时，你才应该想办法去清理阻塞。</p>
<p>第一选择是使用能够和你应用的其他部分彻底隔离的转换方式。举个处理JSON的例子。</p>
<p>当我从服务器获取JSON数据时，我喜欢把它转化成中间对象，以便之后可以归到模型对象中。原因如下：</p>
<ol>
<li>我不希望模型对象知道JSON的存在。</li>
<li>我希望能处理NSNull一类的值，日期转化，还有其他任何对象接手数据之前的所有其他的转化。</li>
</ol>
<p>所以我用一个NSOperationQueue或者GCD队列（最近通常是后者）来把服务器返回的NSData转化成中间对象。</p>
<p>（尽量使用队列。绝不要使用<code>detachThreadSelector</code>或者<code>performSelectorInBackground</code>。）</p>
<p>这些中间对象每次会被单一线程获取。它们在后台线程被创建，然后被传到主线程，在那里被用于更新模型，然后被丢弃。</p>
<p>因为它们在生命周期中被不同的线程引用，我确信这些对象除了它们自己之外什么都不知道，只知道被传入它们的init方法中的是神马。一旦在队列中被创建，它们就是不可变的了。它们不观察任何事，也没有人观察它们（毕竟，它们是不改变的）。</p>
<p>（从不改变的对象是线程安全的这个角度来看，那些对象是完全线程安全的。然而，没必要强迫线程安全，因为重要的是它们在单一线程的一次使用时是安全的，而非同时在多个线程。）</p>
<h4 id="对象和它的小伙伴"><a href="#对象和它的小伙伴" class="headerlink" title="对象和它的小伙伴"></a>对象和它的小伙伴</h4><p>有时候很多对象会协同工作。放下JSON，我们来考虑RSS解析器。在这个例子中，涉及到三个主要对象：一个SAX解析器的封装器，它的代理方法，和这个代理创建的中间对象。（概念上来说，和上面例子中的对象非常像。）</p>
<p>SAX解析器的封装器和它的代理的生命周期贯穿整个操作。它们不需要是线程安全的，尽管代码运行中单独的线程中 —— 因为它们<em>只</em>被那个线程获取。当它们在工作时，它们对外面的世界一无所知，而外贸的世界对于它们也是一无所知。</p>
<ol>
<li>SAX解析器的封装器知道它初始化时候用的NSData，知道它有一个代理。</li>
<li>SAX解析器的封装器知道它创建的中间对象。</li>
<li>中间对象什么都不知道。</li>
</ol>
<p>于是，这些对象协同工作，但是，重要的是，它们从不使用KVO或者通知模式。它们使用代理模式来取而代之（或者使用block和函数在理论上都不重要）。</p>
<p>这些对象协同工作，但同时也尽可能的保持这个团队与它的任务独立地分离开。</p>
<p>最后，只有中间对象会留存下来 —— 它们被传回主线程，也就是在那里它们被用来更新模型。然后它们也被丢弃。</p>
<h4 id="最糟糕的场景"><a href="#最糟糕的场景" class="headerlink" title="最糟糕的场景"></a>最糟糕的场景</h4><p>我多次重复了“更新模型”这个词组，并提到在主线程做这件事。几年前我从没有梦想过可以这么干 —— 但电脑和设备已经变得如此迅速，以至于可以实现优先考虑只运行在主线程，然后，只有当处理能够、并且应该被安全挪到队列中的其他所有事情时，再考虑其他可选项。</p>
<p>你不会<em>真的</em>想要在后台线程中更新模型。它是个生产崩溃的机器。但是测试和性能剖析可能会告诉你你需要这么做。</p>
<p>试着解决这个问题。如果更新模型<em>除了</em>一件事外其他都好 —— 比如说，涉及到将NSData转换成UIImage或者NSImage —— 那就<em>仅仅把慢的那部分</em>挪到后台任务中。（通过data或者文件来创建图片，把这个挪出主线程实在是一件完美的事。它很容易被隔离开。）</p>
<p>可能有问题的是数据库：可能你发现它在内存中创建对象、更新属性都很快，即使有一堆也是如此。在那种场景中，你可能就会像我一样，把数据库的调用从主线程中分离出来。（并没有那么难：数据库需要在一系列的后台线程中运行，它要按照严格的顺序来执行那些主线程中的任务。）</p>
<p>也就是说：是存在其他可选项的。</p>
<p>但是如果你仍然发现你不得不在后台线程中更新模型，那就不得不这么做吧。切记你应用的 其他部分是在主线程上，所以在发送通知或者做其他事情时，在主线程上处理。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在主线程上做每件事。对于队列和后台线程想都不要想。享受天堂吧！</p>
<p>如果在测试和性能分析后，你发现自己不得不把一些东西挪到后台队列中，挑那些可以被完美分离的部分，并保证它们被完美隔离开。使用代理模式；不要使用KVO或者通知模式。</p>
<p>最后，如果你仍然需要走些野路子 —— 比如说在后台队列中更新你的模型 —— 切记你应用的其他部分要么是运行在主线程上，要么是不分割的整体，能让你在走野路子时不必考虑它们。然后：小心行事，不要乐观太早。（乐观主义者创造崩溃。）</p>
</div></article></div></main><footer><div class="paginator"><a href="/2015/11/19/Mac常用快捷键记录/" class="prev">PREV</a><a href="/2015/11/16/【译】如何避免程序崩溃-3：NSNotification/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2017 <a href="http://www.calios.gq">Calios</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>