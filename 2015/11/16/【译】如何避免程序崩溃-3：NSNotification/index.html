<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 【译】如何避免程序崩溃-3：NSNotification · Calios' Eden</title><meta name="description" content="【译】如何避免程序崩溃-3：NSNotification - Calios"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/img/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.calios.gq/atom.xml" title="Calios' Eden"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/img/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link active">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/calios1124" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/caliosd" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">【译】如何避免程序崩溃-3：NSNotification</h1><div class="post-info">2015年11月16日</div><div class="post-tags"><a href="/tags/iOS/" class="post-tag"> iOS</a><a href="/tags/译言/" class="post-tag"> 译言</a><a href="/tags/NotToCrashSeries/" class="post-tag"> NotToCrashSeries</a></div><div class="post-content"><p>原文链接：<a href="http://inessential.com/2015/05/21/how_not_to_crash_3_nsnotification" title="http://inessential.com/2015/05/21/how_not_to_crash_3_nsnotification" target="_blank" rel="external">http://inessential.com/2015/05/21/how_not_to_crash_3_nsnotification</a></p>
<hr>
<p>通常来说，和KVO与（特别是）绑定相比，我更喜欢NSNotification。我的确有时候用KVO —— 每当这时它都是那最敏感的部分。但是NSNotification像很多比较老的API一样，是很容易使用而不会导致崩溃的。</p>
<p>但是你还是要小心。</p>
<h4 id="一种导致崩溃的方式"><a href="#一种导致崩溃的方式" class="headerlink" title="一种导致崩溃的方式"></a>一种导致崩溃的方式</h4><p>当一个对象注册了一个通知，然后没有取消注册就被销毁了，然后应用就会在发送通知的时候崩溃掉。这是你需要避免的。文章余下的部分就来说说该怎么做。</p>
<h4 id="一条重要规则"><a href="#一条重要规则" class="headerlink" title="一条重要规则"></a>一条重要规则</h4><p>我有一条简单而粗暴有效的规则：<em>只在主线程</em> 发送NSNotification。无一例外。如果一些代码运行在另一个线程，而它需要发送一个通知，那它必须在主线程做这件事。</p>
<p>这就避免了所有你不希望的线程发来的通知所导致的问题。这样也避免了因为没有取消通知注册而带来的一团乱麻的情形。</p>
<p>一个应用基本上所有的代码都应在运行在主线程中。NSOperation或者GCD queue中运行的代码应该和其他所有代码分离开，当多个对象协同工作时应该用代理模式（用或者不用block）。</p>
<p>保证通知总是在主线程被发送应该是 <em>小菜一碟</em>。（我会在另一篇《如何避免程序崩溃》系列的文章中详细将线程和队列。）</p>
<h4 id="批量取消注册"><a href="#批量取消注册" class="headerlink" title="批量取消注册"></a>批量取消注册</h4><p>有些人喜欢在<code>dealloc</code>中做些额外的维护工作，来精确地给每个NSNotification取消注册。你会看到这样的代码：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-attr">[[NSNotificationCenter defaultCenter]</span> <span class="selector-tag">removeObserver</span><span class="selector-pseudo">:self</span> <span class="selector-tag">name</span><span class="selector-pseudo">:kSomeNotificationName</span> <span class="selector-tag">object</span><span class="selector-pseudo">:someObject</span>];</div><div class="line"><span class="selector-attr">[[NSNotificationCenter defaultCenter]</span> <span class="selector-tag">removeObserver</span><span class="selector-pseudo">:self</span> <span class="selector-tag">name</span><span class="selector-pseudo">:kSomeOtherNotificationName</span> <span class="selector-tag">object</span><span class="selector-pseudo">:someOtherObject</span>];</div><div class="line"><span class="selector-tag">etc</span>...</div></pre></td></tr></table></figure></p>
<p>你可以证明你写的是对的。但是简单扫一眼代码是不够的 —— 随着时间的增长，你不得不仔细思考自己的代码。</p>
<p>以后，你或者别人可能会添加另一个通知，然后忘了为那个通知调用<code>removeObserver</code>。然后，就崩溃了。</p>
<p>另一个问题是，未来接手的人可能不得不通读你的代码，仔细核查来确保每个注册的通知都被移除了。这就是痛点：手动工作而又易出错。</p>
<p>相反，经常这么写：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="section">[NSNotificationCenter defaultCenter removeObserver:self]</span><span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p>如果是印第安那·琼斯（《夺宝奇兵》的主角），他会这么做。</p>
<h4 id="当心多次注册"><a href="#当心多次注册" class="headerlink" title="当心多次注册"></a>当心多次注册</h4><p>如果一个对象注册了一个通知，然后又注册一遍，通知的处理函数会被调用两次。不会自动合并。</p>
<p>（这在过去的日子里经常发生在iOS中的viewDidLoad。人们会把注册代码放在那里 —— 但是，别忘了视图可以被卸载和重新加载，这就意味着对于同一个通知的多次注册。）</p>
<p>你的通知的处理函数应该对于被调用两次做相应处理。也不应该让给定对象注册两次相同的通知成为可能。二者都要注意。</p>
<h4 id="在init中注册，在dealloc中取消注册"><a href="#在init中注册，在dealloc中取消注册" class="headerlink" title="在init中注册，在dealloc中取消注册"></a>在init中注册，在dealloc中取消注册</h4><p>几乎在每种情况下，我都在init方法中注册观察者，然后在<code>dealloc</code>中移除观察者。如果我发现一个对象需要在它的生命周期里添加和移除观察者，我会视之为强壮的代码。</p>
<p>这是个很好的机会，1）要么是它并不是真正需要这么做 2）这个对象需要划分成更小的对象。</p>
<p>你知道对于一个给定的对象而言，init方法只会被调用一次。你也知道dealloc方法只会在没有其他对象引用这个对象时被调用一次。你可以使用这个知识点来保持注册和取消注册之间的平衡，而不必去思考或者跟踪它。如此简单。</p>
<h4 id="避免addObserverForName"><a href="#避免addObserverForName" class="headerlink" title="避免addObserverForName"></a>避免addObserverForName</h4><p>有些人喜欢<code>-[NSNotificationCenter addObserverForName: object: queue: usingBlock:]</code>。这感觉很时髦，因为是基于block的，而我们都喜欢block。（我确信）</p>
<p>但是这是个糟糕的主意。你可能本可以保留自己写的处理通知的方法，但是你也让你的整理工作更加糟糕，因为现在你就额外多了一个对象需要照看，又需要稍后调用<code>removeObserver</code>。这就意味着没有批量取消注册；它意味着你要回去做审核的工作，这就意味着你又多了一件事情要保障。</p>
<p>基于block的版本意味着你可以让注册和处理通知一起保留 —— 但是这么做的话，在整理工作和潜在崩溃方面的代价实在是太大了。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2015/11/19/【译】如何避免程序崩溃-4：线程（一）/" class="prev">PREV</a><a href="/2015/11/13/【译】如何避免程序崩溃-2：可变对象的异常/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2017 <a href="http://www.calios.gq">Calios</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>