<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> [SourceRead]-SDWebImage-3 · Calios' Eden</title><meta name="description" content="[SourceRead]-SDWebImage-3 - Calios"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/img/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.calios.gq/atom.xml" title="Calios' Eden"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/img/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link active">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/calios1124" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/caliosd" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">[SourceRead]-SDWebImage-3</h1><div class="post-info">2016年2月15日</div><div class="post-tags"><a href="/tags/iOS/" class="post-tag"> iOS</a><a href="/tags/SourceRead/" class="post-tag"> SourceRead</a></div><div class="post-content"><p><img src="http://7xkwcv.com1.z0.glb.clouddn.com/QQ20160216-0@2x.png" alt="" title="SDWebImage系列"></p>
<p>沿着上面这个图，一层一层剥到了<code>SDWebImageDownloader</code>的<code>- downloadImageWithURL:options:progress:completed:</code>方法，终于看到了大片的原生代码在向我们招手。。。</p>
<p>纵观这个方法，就调用了一下<code>-addProgressCallback:completedBlock:forURL:createCallback:</code>，而这个方法并不复杂，主要展示了一下<code>self.URLCallbacks</code>这个字典的内部组成，在此略去不提。</p>
<p>还是回来看<code>- downloadImageWithURL:options:progress:completed:</code>。</p>
<h3 id="［1］Cache-Control"><a href="#［1］Cache-Control" class="headerlink" title="［1］Cache-Control"></a>［1］Cache-Control</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSMutableURLRequest *request = [[NSMutableURLRequest alloc] <span class="string">initWithURL:</span>url <span class="string">cachePolicy:</span>(options &amp; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData) <span class="string">timeoutInterval:</span>timeoutInterval];</div></pre></td></tr></table></figure>
<p>基本的<code>NSMutableURLRequest</code>初始化，没什么问题，主要看缓存策略：<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="name">options</span> &amp; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData)</div></pre></td></tr></table></figure></p>
<p>先来简单了解一下Cache-Control：</p>
<blockquote>
<p>每个资源都可以通过 Cache-Control HTTP 头来定义自己的缓存策略<br>Cache-Control 指令控制谁在什么条件下可以缓存响应以及可以缓存多久</p>
</blockquote>
<p>更多深入内容可以看<a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching" title="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching" target="_blank" rel="external">这里</a>。</p>
<ul>
<li><code>SDWebImageDownloaderUseNSURLCache</code>: 默认情况下，<code>SDWebImage</code>是不使用<code>NSURLCache</code>的，如果使用这个选项，那么就将<code>NSURLCache</code>的默认的缓存策略作为缓存策略，即<code>NSURLRequestUseProtocolCachePolicy</code>。</li>
<li><code>NSURLRequestUseProtocolCachePolicy</code>: 这个缓存策略是URL请求的默认策略，即在指定的URL请求中使用协议中实现了的缓存逻辑。</li>
<li><code>NSURLRequestReloadIgnoringLocalCacheData</code>: 指定了某个URL的数据要从原始地址获取，无视已有缓存。</li>
</ul>
<p>所以，这里的缓存策略是：如果传入的<code>option</code>是<code>SDWebImageDownloaderUseNSURLCache</code>，就用NRURLCache的默认缓存策略，否则就无视本地缓存，重新获取。</p>
<h3 id="［2］NSMutableURLRequest的几个属性"><a href="#［2］NSMutableURLRequest的几个属性" class="headerlink" title="［2］NSMutableURLRequest的几个属性"></a>［2］<code>NSMutableURLRequest</code>的几个属性</h3><figure class="highlight nix"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">request.<span class="attr">HTTPShouldHandleCookies</span> = (options &amp; SDWebImageDownloaderHandleCookies);</div><div class="line">request.<span class="attr">HTTPShouldUsePipelining</span> = YES;</div><div class="line">request.<span class="attr">allHTTPHeaderFields</span> = wself.HTTPHeaders; // 这里略去了原代码中的<span class="keyword">if</span>判断</div></pre></td></tr></table></figure>
<ul>
<li><code>HTTPShouldHandleCookies</code>: 是否对当前请求使用默认cookie。默认为YES。也就是说，默认情况下cookie是由cookie manager存储和发送的。</li>
<li><code>HTTPShouldUsePipelining</code>: 是否等待前一个请求响应后再发送当前请求。YES是不等，NO是等。（第三个选项是爱等不等。。。XD）</li>
<li><code>allHTTPHeaderFields</code>: 用设置的NSDictionary（key和value都需为NSString）来替代之前可能存在的所有header字段。</li>
</ul>
<p>比如初始化时的<code>HTTPHeaders</code>长这样：<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SD_WEBP</span></div><div class="line">    <span class="variable">_HTTPHeaders</span> = [@&#123;@<span class="string">"Accept"</span>: @<span class="string">"image/webp,image/*;q=0.8"</span>&#125; mutableCopy];</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    <span class="variable">_HTTPHeaders</span> = [@&#123;@<span class="string">"Accept"</span>: @<span class="string">"image/*;q=0.8"</span>&#125; mutableCopy];</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure></p>
<h3 id="［3］将Class作为属性值存储"><a href="#［3］将Class作为属性值存储" class="headerlink" title="［3］将Class作为属性值存储"></a>［3］将Class作为属性值存储</h3><p>一个开发的小技巧：<br><figure class="highlight monkey"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 头文件中的声明</div><div class="line">@<span class="keyword">property</span> (assign, nonatomic) <span class="class"><span class="keyword">Class</span> <span class="title">operationClass</span>;</span></div><div class="line">// 初始化指定具体<span class="class"><span class="keyword">class</span></span></div><div class="line">    _operationClass = [SDWebImageDownloaderOperation <span class="class"><span class="keyword">class</span>];</span></div><div class="line">// 使用时调用具体<span class="class"><span class="keyword">class</span>的方法</span></div><div class="line">operation = [[wself.operationClass alloc] initWithRequest:request</div><div class="line">options:options progress:^(NSInteger receivedSize, NSInteger expectedSize) &#123;</div><div class="line">    ...</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<h3 id="［4］NSURLCredential"><a href="#［4］NSURLCredential" class="headerlink" title="［4］NSURLCredential"></a>［4］<code>NSURLCredential</code></h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (wself.urlCredential) &#123;</div><div class="line">      operation.credential = wself.urlCredential;</div><div class="line"> &#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (wself.username &amp;&amp; wself.password) &#123;</div><div class="line">      operation.credential = [NSURLCredential <span class="string">credentialWithUser:</span>wself.username <span class="string">password:</span>wself.password <span class="string">persistence:</span>NSURLCredentialPersistenceForSession];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的<code>urlCredential</code>是一个<code>NSURLCredential</code>类的属性。如果这个属性存在就用这个属性，没有的话，就用用户名和密码创建一个仅存储于当前session中的<code>NSURLCredential</code>。</p>
<p>那么，<code>NSURLCredential</code>是个神马呢？先引用一段MK的讲解来了解下HTTP认证的机理：</p>
<blockquote>
<p>当客户端向服务器发起资源请求时，它会发起一个以文件名结尾的GET请求。如果服务器检查到资源是被保护的，就会返回一个header中有WWW-Authenticate的401消息，告知客户端“未被授权”。WWW-Authenticate这个header字段可能有值，由相应机制来决定这个值是“Basic”还是“Digest”。<br>当客户端接收到这个授权挑战（challenge）时，它就要以指定格式将用户授权信息发过去。对于基本的认证，通常是在header的认证字段中放上base64加密过的用户名和密码。对于摘要式认证，就要略复杂一点。客户端在header的认证字段中要放的值也更加高精尖一些。幸运的是，作为Objective-C的开发者们，CoreFoundation类已经把这些都封装好了。</p>
</blockquote>
<p>一旦请求的URL需要授权，即服务器返回了含有WWW-Authenticate的header，<code>NSURLConnection</code>的<code>NSURLCredential</code>相关的代理方法<code>-connection:willSendRequestForAuthenticationChallenge:</code>就会被调用。</p>
<p>全局搜<code>willSendRequestForAuthenticationChallenge</code>，果然在<code>SDWebImageDownloaderOperation.m</code>的末尾找到了一段。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)<span class="string">connection:</span>(NSURLConnection *)connection <span class="string">willSendRequestForAuthenticationChallenge:</span>(NSURLAuthenticationChallenge *)challenge&#123;</div><div class="line">    <span class="keyword">if</span> ([challenge.protectionSpace.authenticationMethod <span class="string">isEqualToString:</span>NSURLAuthenticationMethodServerTrust]) &#123;</div><div class="line">        <span class="comment">// `SDWebImageDownloaderAllowInvalidSSLCertificates`:Enable to allow untrusted SSL certificates.</span></div><div class="line">        <span class="comment">// 不允许使用不可信的SSL证书 －》 只允许使用可信证书</span></div><div class="line">        <span class="keyword">if</span> (!(self.options &amp; SDWebImageDownloaderAllowInvalidSSLCertificates) &amp;&amp;</div><div class="line">            [challenge.sender <span class="string">respondsToSelector:</span><span class="meta">@selector</span>(<span class="string">performDefaultHandlingForAuthenticationChallenge:</span>)]) &#123;</div><div class="line">            <span class="comment">// 让认证挑战的发送者按照系统指定的进行默认操作。</span></div><div class="line">            [challenge.sender <span class="string">performDefaultHandlingForAuthenticationChallenge:</span>challenge];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 新建一个已经有一次可信任握手的`NSURLCredential`。</span></div><div class="line">            NSURLCredential *credential = [NSURLCredential <span class="string">credentialForTrust:</span>challenge.protectionSpace.serverTrust];</div><div class="line">            <span class="comment">// 让认证挑战的发送者使用新建的这个credential来应答认证挑战。</span></div><div class="line">            [[challenge sender] <span class="string">useCredential:</span>credential <span class="string">forAuthenticationChallenge:</span>challenge];</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> ([challenge previousFailureCount] == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (self.credential) &#123;</div><div class="line">                [[challenge sender] <span class="string">useCredential:</span>self.credential <span class="string">forAuthenticationChallenge:</span>challenge];</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                [[challenge sender] <span class="string">continueWithoutCredentialForAuthenticationChallenge:</span>challenge];</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            [[challenge sender] <span class="string">continueWithoutCredentialForAuthenticationChallenge:</span>challenge];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在细看代理方法实现前先来了解一下这几个陌生的类：</p>
<ul>
<li><code>NSURLAuthenticationChallenge</code>: 这个类是认证挑战类，客户端接受挑战就意味着要提供挑战的凭证（比如用户名、密码等等）。</li>
<li><code>NSURLCredential</code>: 这个类是代表着认证凭证的一个不可变的对象，它由指定类型的认证信息和可用的存储时间组成。</li>
</ul>
<p>是不是有种每个字都认识连起来就晕了的感觉？打个比方理解下～</p>
<p>当～～～～ 夕阳余晖已散，一个笑面书生要从东城门口入城，守城士兵一枪拦住：“呔！何方人氏，敢夜闯我四方城？有通关文书否？”（401，未被授权，遭到授权挑战，<code>-connection:willSendRequestForAuthenticationChallenge:</code>被调用）书生上前一步，拱手朗声道：“在下皇甫仁和，应城主邀请入城一叙。有城主亲笔书函在此。”说着，从袖中抽出一封信（即认证的凭证<code>NSURLCredential</code>），递了过去（向<code>NSURLAuthenticationChallenge</code>挑战的发送者提供<code>NSURLCredential</code>凭证）。士兵接过信，见确为城主字迹，信中的邀请日期正是当日（该凭证的有效期），且有四方城印一枚附在信尾（认证需要的详细信息），方信了。随机撤了长枪，甩手道：“请！”（认证通过了，可以获取资源了）</p>
<h3 id="［4］operation的LIFO执行顺序"><a href="#［4］operation的LIFO执行顺序" class="headerlink" title="［4］operation的LIFO执行顺序"></a>［4］operation的LIFO执行顺序</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (wself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</div><div class="line">     <span class="comment">// 将最新添加的operation作为最后一个的operation的依赖，也就是说，要先执行最新添加的operation，再往前依次执行，即实现了“后进先出LIFO”。</span></div><div class="line">     [wself.lastAddedOperation <span class="string">addDependency:</span>operation];</div><div class="line">     wself.lastAddedOperation = operation;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p><strong>Ref:</strong></p>
<ul>
<li>HTTP缓存：<br>  <a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching" target="_blank" rel="external">https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching</a></li>
<li>Authenticating with a RESTful service using NSURLCredential：<br>  <a href="http://blog.mugunthkumar.com/articles/iphone-tutorial-authenticating-with-a-restful-service-using-nsurlcredential/" target="_blank" rel="external">http://blog.mugunthkumar.com/articles/iphone-tutorial-authenticating-with-a-restful-service-using-nsurlcredential/</a></li>
</ul>
</div></article></div></section><footer><div class="paginator"><a href="/2016/02/15/[SourceRead]-PureLayout/" class="prev">PREV</a><a href="/2016/01/31/[SourceRead]-SDWebImage-2/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2017 <a href="http://www.calios.gq">Calios</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>