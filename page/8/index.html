<!DOCTYPE html>
<html lang="en">
  <head><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="Stedfast as thou art."/><link rel="alternate" href="/default" title="Calios' Eden"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0" />
<link rel="canonical" href="http://www.caliosd.gq/page/8/"/>

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0" />

<script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":false};
</script>

    <title>Calios' Eden</title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Calios' Eden</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">Home
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">Archives
          </li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags
          </li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories
          </li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Calios' Eden</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            Home
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            Archives
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/tags/">
            Tags
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/categories/">
            Categories
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/about/">
            About
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><section id="posts" class="posts"><article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2015/12/19/how-not-to-crash-7-dealing-with-nothing/">【译】如何避免程序崩溃-7：什么都不做</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2015-12-19
        </span></div>
    </header>

    <div class="post-content"><p>原文链接：<a href="http://inessential.com/2015/05/29/how_not_to_crash_7_dealing_with_nothin" target="_blank" rel="external">http://inessential.com/2015/05/29/how_not_to_crash_7_dealing_with_nothin</a></p>
<hr>
<p>考虑下这行代码：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="section">[thing doStuff]</span><span class="comment">;</span></div></pre></td></tr></table></figure>
<p>如果<code>thing</code>是nil，没有什么问题。不会崩溃。什么都不会发生。</p>
<p>但是你不能由此推断nil在所有场景中都没有问题：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="section">[self doStuff:thing]</span><span class="comment">;</span></div></pre></td></tr></table></figure>
<p>如果<code>thing</code>是nil，接下来会发生什么？如果取决于<code>doStuff:</code>的实现 —— 它可能会崩溃。考虑下这行代码：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">menuItem.title = thing<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>如果<code>menuItem</code>是一个NSMenuItem对象，那么当<code>thing</code>为nil时它就会崩溃。NSMenuItem的头文件没有提到这个，就连文档中也只是一笔带过（“如果你不想要标题，就用一个空字符串代替（@“”），而不是nil。”）</p>
<p>这就意味着你需要保证<code>thing</code>是非空的。你可能很确信它是非空的。但是考虑下我曾经遇到的一个例子，当<code>thing</code>是一个字体的名字时怎么办。我从不会想到获取字体名字的系统API会返回nil —— 除非它偶尔这么做了（当然时很少发生，而且不管我做什么，从未在我的机器上发生）。</p>
<p>需要知道的是：</p>
<p>Nil的接受者是没问题的 —— 只要你的代码对于什么都不做没什么问题。</p>
<p>Nil作为参数可能没问题，也可能有问题。当调用系统的API时，头文件和文档不会总是告诉你可能发生什么。（这一点可能会在他们充分利用<a href="https://developer.apple.com/swift/blog/?id=25" title="https://developer.apple.com/swift/blog/?id=25" target="_blank" rel="external"><code>_Nullable</code>和<code>_Nonnull</code></a>时有所改善。）</p>
<p>不要相信任何人。</p>
<h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4><p>断言是一种证明假设和需求的不错的方式，也是确保假设为真的有效工具。断言不该在发布版本中运行（详见Xcode设置中的ENABLE_NS_ASSERTIONS）。</p>
<p>我最喜欢的一个是NSParameterAssert，我几乎专门用它来做不能为空参数的为空检查。</p>
<p>用起来超级简单：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)someMethod:(<span class="keyword">id</span>)someParameter &#123;</div><div class="line">  <span class="built_in">NSParameterAssert</span>(someParameter);</div><div class="line">  …<span class="keyword">do</span> whatever…</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以后我可能开始使用<code>_Nullable</code>/<code>_Nonnull</code>注释<em>和</em>NSParameterAssert。两个都用。（未来我可能会写些Swift的代码，那时候对于nil的处理就是另一回事了。但是那不是我今天谈论的内容，一部分的原因是，我对于Swift还不足以称为专家，不能给出好的建议。）</p>
<p>我也经常使用NSAssert。NSAssert需要一个表达式和一个评论文字 —— 但我很懒，总把评论置为空。（这种情况下是没问题的。）<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSAssert(<span class="name">something</span> == somethingElse, <span class="literal">nil</span>)<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p>（关于懒惰的一点建议：懒的程序员从不写崩溃的bug，因为他们不想之后再回来修复它们。）</p>
<h4 id="我喜欢的崩溃的bug"><a href="#我喜欢的崩溃的bug" class="headerlink" title="我喜欢的崩溃的bug"></a>我喜欢的崩溃的bug</h4><p>几年前，我的app NetNewsWire有一个崩溃日志捕捉者。在启动应用时，它会从磁盘中抓取最新的崩溃日志发送给我。</p>
<p>随着一些OS X系统的发布（我想是10.5）苹果公司修改了磁盘中崩溃日志的形式。我想它们曾经是每个应用一个日志文件，然后苹果改成了每次崩溃一个日志文件。我不得不写些新的代码来处理新的形式。</p>
<p>我做了修改。发给了beta版的测试者，他们专门用这个app。几周过去了。一切安好。</p>
<p>然后，就在我发布这个版本的当天，我接到了成千上万的报告者说，“在启动应用的时候就挂掉了！但是再次启动的时候就好了。”</p>
<p>解决方法如下：新的代码会在根本没有崩溃日志的时候崩溃掉。然后，在下次启动的时候 —— 既然有了崩溃日志 ——它就不会崩溃了。（是的，这是个可以自愈的崩溃bug。在崩溃日志捕捉器内。就是这样。）</p>
<p>当然这就意味着对所有<em>新</em>用户来说，它会立即崩溃，而不只是那些足够幸运、从未崩溃过的人们。</p>
<p>这对我是个极大的提醒：<em>一定要考虑什么都没有的情况</em>。总是什么都不发生。什么都没有是很平常的。但是可能需要特殊处理，也应该被考虑到。</p>
<h4 id="一个没那么酷的崩溃bug"><a href="#一个没那么酷的崩溃bug" class="headerlink" title="一个没那么酷的崩溃bug"></a>一个没那么酷的崩溃bug</h4><p>我认为这不会转移 —— 我想它只存在于beta版的代码中。</p>
<p>Vesper的同步会与服务器对话。服务器将JSON数据返回。Cocoa的JSON解析器将JSON的null转化成<code>NSNull</code>对象。</p>
<p>Vesper期望得到一个NSString，却得到了一个NSNull。Vesper试图对NSNull调用一个字符串的方法，然后它就挂掉了。</p>
<p>表面上看来这是一个难啃的骨头，因为你不能保证JSON给出的类型是你想要的。你需要一个string，但得到了一个NSNull。</p>
<p>是的，NSNull是你希望能够尽量隔离处理的众多对象中的一个。它是个四处游走的问题代码（尽管我不知道在JSON的null的例子中类似的例子是什么）。（你绝不应该在JSON之外特意使用它。几乎绝不应该。绝对少用。比如说几年用一次，而且得是你真的真的不得不用的时候。可能连那样都不应该用。）</p>
<p>这就是像我<a href="http://www.caliosd.gq/2015/11/19/how-not-to-crash-4-threading/" title="http://www.caliosd.gq/2015/11/19/how-not-to-crash-4-threading/">之前那篇</a>提到的，我喜欢把JSON转化成中间对象的部分原因吧。这么做的一大部分工作就集中在处理NSNull对象上 —— 我不想把它们渗透到应用的其它部分上去，那样所到之处都会变得脏兮兮的。</p>
<p>但是，另一个观点是：<em>只要是写服务器端的人，就是你不共戴天的仇人</em>。他非常非常的恨你。</p>
<p>在这里，Vesper的案例中，是我扮演了这样的角色。但我仍然要假设写服务器那家伙把完成我本人和事业的摧毁当作他们的终极目标一样地写代码。（尽管我了解那个家伙，他很酷。他喜欢小猫咪。）同时，那不意味着只检查NSNull —— 不管怎样它在JSON中很常见 —— 而是要对每一部分数据的类型都谨慎处理。</p>
<p>任何事情都可能在不确定的时间变成不可预知的事情。</p>
<p>（并非一路通畅。你期望能够一帆风顺 —— 但是那也太容易了。可能一路下来什么都没有。）</p>
<h4 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h4><p>初始化你的变量。就这样。如果我每修复一个仅仅将变量初始化为nil就解决的崩溃bug就能拿到一个硬币的话 —— 那我已经有好些硬币了。你肯定希望不要获得这样的硬币。</p>
<p>不初始化你的变量就像在玩汽油，然后还说，没问题的，因为火柴在口袋里。</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2015/12/15/pitfall-1/">Cell的复用机制</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2015-12-15
        </span></div>
    </header>

    <div class="post-content"><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>最近踩到了一个以前没有注意的坑。场景是这个样子的。</p>
<blockquote>
<p>一个UICollectionView有个自定义的UICollectionViewCell，UICollectionViewCell中有个UITableView，在点击UITableView的cell时，需要将点击之后更新的model（为一个NSArray）传出来给UICollectionView，UICollectionView用一个NSMutableDictionary接。<br>假设用delegate一层层传出来。<br>会出现这样的问题：</p>
<ul>
<li>Cell0中，点击UITableView的cell，传出来的值为<code>@[@&quot;0&quot;]</code>，UICollectionView接到的值为<code>@[@&quot;0&quot;]</code>，更新后的字典为<code>@{ 0 = (0);}</code>；</li>
<li>水平滑动collectionView，显示Cell1，点击UITableView的cell， UITableView传出来的值为<code>@[@&quot;1&quot;]</code>，UICollectionView接到的值为<code>@[@&quot;1&quot;]</code>，更新后的字典为<code>@{ 0 = (0); 1 = (0);}</code>；</li>
<li>继续水平滑动collectionView，显示Cell2，点击UITableView的cell， UITableView传出来的值为<code>@[@&quot;6&quot;]</code>，UICollectionView接到的值为<code>@[@&quot;6&quot;]</code>，更新后的字典为<code>@{ 0 = (6); 1 = (0); 2 = (6);}</code>；</li>
<li>问题出现了，key为2的value会把key为0的value覆盖掉。</li>
<li>所以呢？</li>
</ul>
</blockquote>
<p>一入小坑深似海，从此清闲是路人。</p>
<p>此处略去十几根青丝。</p>
<p>还好，某日正午的咖啡香中，灵光闪现。很可能是key为2的value和key为0的value对应相同的地址。所以，2的value就把0的value给覆盖了。打断点依次打印了一下更新后字典中各个元素的地址，果然如此。</p>
<p>爬出来了。</p>
<h4 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h4><p>导致这个问题的表面原因，可能是由于UICollectionViewCell的复用机制。在每页显示一个cell的情况下，当显示index0的cell，假设其中成员变量的指向的地址为<em>0x00001</em>，；当显示index2的cell时，复用了index0的cell，同样也就复用了其中的成员变量，即上文中传出来的数组。而在调用delegate方法时，直接就把这个数组作为参数传入。接下来层层代理出来，最终collectionView获得的值也是换汤不换药地指向原来数组的地址<em>0x00001</em>。所以就导致UICollectionView中字典key为0和key为2的值相同。</p>
<p>深究原因的话，还是代码的防御性不强。从别处获取的值不应该拿过来就直接使用，而应该复制给一个新的变量，之后自己继续用这个新的变量。反过来，作为传出去的参数，最好也能略微封装一下，不要把private的成员变量直接就传出去，防止引入外面的污染。</p>
<p><strong>PS：</strong><br>当然，对于从UITableView传值出去，通知机制会更方便些，免得一层层的写代理。但也要注意同样的问题。提高自己代码的健壮性。</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2015/12/14/auto-layout-best-practices-for-minimum-pain/">【译】Auto Layout的最佳实践 —— 止疼片</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2015-12-14
        </span></div>
    </header>

    <div class="post-content"><p>原文链接：<a href="https://medium.com/@NSomar/auto-layout-best-practices-for-minimum-pain-c130b2b1a0f6#.tqby1u8l4" target="_blank" rel="external">https://medium.com/@NSomar/auto-layout-best-practices-for-minimum-pain-c130b2b1a0f6#.tqby1u8l4</a></p>
<hr>
<p>Auto Layout是个很棒的工具，作为开发者，它可以让我们保持神志清醒，还能让我们这些懒人们在设置frame的时候远离“神奇数字”。</p>
<p>但是任何技术都不是完美无缺的，我必须得说我花了太多的时间来debug那些缺失的约束条件，或者对于一些藏在层级结构深处的视图，添加一个冲突的约束条件就会把整个布局毁掉，当这些事情发生的时候简直是天崩地裂！</p>
<p>在debug了无数个小时的auto layout的问题后，我发现每次造成问题的都是我自己（或者是你自己！），而问题的解决办法总是相同的：遵从auto layout的文档和规则！</p>
<p>我会在这里把正确使用auto layout的最佳实践说给你听，这样你就可以免除一些痛苦了。</p>
<h4 id="UIView的子类应该实现intrinsicContentSize方法"><a href="#UIView的子类应该实现intrinsicContentSize方法" class="headerlink" title="UIView的子类应该实现intrinsicContentSize方法"></a>UIView的子类应该实现intrinsicContentSize方法</h4><p>每个<em>UIView</em>的子类都应该实现<em>intrinsicContentSize</em>，并且返回它认为合适的大小。</p>
<p>假设我们新建了一个<em>AwesomeView</em>，而且我们知道这个view的默认尺寸是300x20，我们会这么写：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">CGSize</span>)intrinsicContentSize &#123;</div><div class="line"> <span class="keyword">return</span> <span class="built_in">CGSizeMake</span>(<span class="number">300</span>, <span class="number">20</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果我们不知道view的宽度，我们会用<em>UIViewNoIntrinsicMetric</em>来代替：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">CGSize</span>)intrinsicContentSize &#123;</div><div class="line"> <span class="keyword">return</span> <span class="built_in">CGSizeMake</span>(<span class="built_in">UIViewNoIntrinsicMetric</span>, <span class="number">20</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>UIView基类的<em>updateConstraints</em>实现会调用<em>intrinsicContentSize</em>，它会使用返回的尺寸来给<em>AwesomeView</em>添加约束条件。</p>
<p>根据上面例子中的(300,20)尺寸，会添加下面的约束条件：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="string">NSContentSizeLayoutConstraint:</span><span class="number">0x7fef48d52580</span> <span class="string">H:</span>[<span class="string">AwesomeView:</span><span class="number">0x7fef48ead7f0</span>(<span class="number">300</span>)] <span class="string">Hug:</span><span class="number">250</span> <span class="string">CompressionResistance:</span><span class="number">750</span>&gt;,</div><div class="line">&lt;<span class="string">NSContentSizeLayoutConstraint:</span><span class="number">0x7fef48d4d110</span> <span class="string">V:</span>[<span class="string">AwesomeView:</span><span class="number">0x7fef48ead7f0</span>(<span class="number">20</span>)] <span class="string">Hug:</span><span class="number">250</span> <span class="string">CompressionResistance:</span><span class="number">750</span>&gt;</div></pre></td></tr></table></figure></p>
<p>添加的约束条件比较特殊，它们是<em>NSContentSizeLayoutConstraint</em>类型的，这个类是个私有类。这些约束条件的优先级范围是0-1000，“包住限制”（译者注：hug consistance，使其在“内容大小”的基础上不能继续变大）的优先级是250，“撑住限制”（compression resistance，撑住使其在在其“内容大小”的基础上不能继续变小）的优先级是750，使用的常量等于通过<em>intrinsicContentSize</em>返回的值。</p>
<p>请注意，UIView基类实现<strong>updateConstraints</strong>只有在它第一次执行的时候才会添加<em>intrinsicContentSize</em>约束。</p>
<h4 id="UIView的子类绝不应该给自身的尺寸添加约束"><a href="#UIView的子类绝不应该给自身的尺寸添加约束" class="headerlink" title="UIView的子类绝不应该给自身的尺寸添加约束"></a>UIView的子类绝不应该给自身的尺寸添加约束</h4><p>每个view都会负责给它的superview设置约束，但是view<strong>绝不应该</strong>设置它自己的约束条件，不管是对于自身的约束（比如说<em> NSLayoutAttributeWidth</em>和<em> NSLayoutAttributeHeight</em>），还是相对于superview的约束。</p>
<p>如果一个view想指定自己的高度或者宽度，它应该通过实现<em> intrinsicContentSize</em>来达到目的。</p>
<p>这是个糟糕的例子：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (instancetype)init</div><div class="line">&#123;</div><div class="line">     self = [<span class="keyword">super</span> init];</div><div class="line">     <span class="keyword">if</span> (self) &#123;</div><div class="line">         [self <span class="string">addConstraint:</span>[NSLayoutConstraint <span class="string">constraintWithItem:</span>self <span class="string">attribute:</span>NSLayoutAttributeWidth <span class="string">relatedBy:</span>NSLayoutRelationEqual <span class="string">toItem:</span>nil <span class="string">attribute:</span><span class="number">0</span> <span class="string">multiplier:</span><span class="number">0</span> <span class="string">constant:</span><span class="number">100</span>]];</div><div class="line">         [self <span class="string">addConstraint:</span>[NSLayoutConstraint <span class="string">constraintWithItem:</span>self <span class="string">attribute:</span>NSLayoutAttributeHeight <span class="string">relatedBy:</span>NSLayoutRelationEqual <span class="string">toItem:</span>nil <span class="string">attribute:</span><span class="number">0</span> <span class="string">multiplier:</span><span class="number">0</span> <span class="string">constant:</span><span class="number">100</span>]];</div><div class="line">     &#125;</div><div class="line">         <span class="keyword">return</span> self;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个view在通过给自身添加约束来设置自己的宽度和高度，那么如果现在它的superview也在试图指定这些数值会发生什么呢？<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Some place in the superview</span></div><div class="line">[awesome <span class="string">addConstraint:</span>[NSLayoutConstraint <span class="string">constraintWithItem:</span>awesome <span class="string">attribute:</span>NSLayoutAttributeWidth <span class="string">relatedBy:</span>NSLayoutRelationEqual <span class="string">toItem:</span>nil <span class="string">attribute:</span><span class="number">0</span> <span class="string">multiplier:</span><span class="number">0</span> <span class="string">constant:</span><span class="number">200</span>]];</div><div class="line">[awesome <span class="string">addConstraint:</span>[NSLayoutConstraint <span class="string">constraintWithItem:</span>awesome <span class="string">attribute:</span>NSLayoutAttributeHeight <span class="string">relatedBy:</span>NSLayoutRelationEqual <span class="string">toItem:</span>nil <span class="string">attribute:</span><span class="number">0</span> <span class="string">multiplier:</span><span class="number">0</span> <span class="string">constant:</span><span class="number">200</span>]];</div></pre></td></tr></table></figure></p>
<p>嘭！<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Unable to simultaneously satisfy constraints.</div><div class="line">…</div><div class="line">property translatesAutoresizingMaskIntoConstraints)</div><div class="line">(</div><div class="line"> “&lt;<span class="string">NSLayoutConstraint:</span><span class="number">0x7ff3b16c2ae0</span> <span class="string">H:</span>[<span class="string">AwesomeView:</span><span class="number">0x7ff3b16bfa00</span>(<span class="number">100</span>)]&gt;”,</div><div class="line"> “&lt;<span class="string">NSLayoutConstraint:</span><span class="number">0x7ff3b16c2330</span> <span class="string">H:</span>[<span class="string">AwesomeView:</span><span class="number">0x7ff3b16bfa00</span>(<span class="number">200</span>)]&gt;”</div><div class="line">)</div><div class="line">Will attempt to recover by breaking constraint</div><div class="line">&lt;<span class="string">NSLayoutConstraint:</span><span class="number">0x7ff3b16c2330</span> <span class="string">H:</span>[<span class="string">AwesomeView:</span><span class="number">0x7ff3b16bfa00</span>(<span class="number">200</span>)]&gt;</div><div class="line">…</div></pre></td></tr></table></figure></p>
<p><code>AwesomeView</code>添加的宽度/高度是100/100，而它的superview也添加了宽度/高度，但是是200/200，这样autoLayout就不知道该选择哪个约束条件了，因为它们的优先级都一样。</p>
<p>一种解决办法是这样的，将<code>AwesomeView</code>自身的优先级降低一点。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[self <span class="string">addConstraint:</span>(&#123;</div><div class="line"> NSLayoutConstraint *constraint;</div><div class="line"> constraint = [NSLayoutConstraint <span class="string">constraintWithItem:</span>self <span class="string">attribute:</span>NSLayoutAttributeWidth <span class="string">relatedBy:</span>NSLayoutRelationEqual <span class="string">toItem:</span>nil <span class="string">attribute:</span><span class="number">0</span> <span class="string">multiplier:</span><span class="number">0</span> <span class="string">constant:</span><span class="number">100</span>];</div><div class="line"> constraint.priority = <span class="number">800</span>;</div><div class="line"> constraint;</div><div class="line"> &#125;)];</div></pre></td></tr></table></figure>
<p>这样autoLayout就可以做出选择了，因为它自身添加的优先级比较低，它就可以选择superview添加的约束了。</p>
<p>然而，尽管这样可以解决问题，但正确的方式是通过<em> intrinsicContentSize</em>来指定它的高度。</p>
<h4 id="UIView的子类绝不应该给它的superview添加约束"><a href="#UIView的子类绝不应该给它的superview添加约束" class="headerlink" title="UIView的子类绝不应该给它的superview添加约束"></a>UIView的子类绝不应该给它的superview添加约束</h4><p>和上面的原因一样，子视图绝不应该给他的父视图添加约束。子视图的位置是由父视图决定的。</p>
<p>像这么做很糟糕：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)didMoveToSuperview &#123;</div><div class="line">     [<span class="keyword">super</span> didMoveToSuperview];</div><div class="line">     [self.superview <span class="string">addConstraint:</span>[NSLayoutConstraint <span class="string">constraintWithItem:</span>self <span class="string">attribute:</span>NSLayoutAttributeCenterX <span class="string">relatedBy:</span>NSLayoutRelationEqual <span class="string">toItem:</span>self.superview <span class="string">attribute:</span>NSLayoutAttributeCenterX <span class="string">multiplier:</span><span class="number">1</span> <span class="string">constant:</span><span class="number">0</span>]];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><em>太糟糕了</em>，它不能离开相对于它的父视图的位置。所以，当父视图想把Awesome放到另一个位置上会怎么样？是的，就会抛出来另一个<em>Unable to simultaneously satisfy constraints</em>的问题。</p>
<h4 id="updateConstraints是用来更新约束条件的"><a href="#updateConstraints是用来更新约束条件的" class="headerlink" title="updateConstraints是用来更新约束条件的"></a>updateConstraints是用来更新约束条件的</h4><p>顾名思义，<code>updateConstraints</code>只是被用来更新需要的约束的。一个正确的实现<code>updateConstraints</code>的方式应该长这个样子：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)init</div><div class="line">&#123;</div><div class="line"> …</div><div class="line"> init stuff</div><div class="line"> …</div><div class="line"> _labelCenterYConstraints = [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:label attribute:<span class="built_in">NSLayoutAttributeCenterY</span> relatedBy:<span class="built_in">NSLayoutRelationEqual</span> toItem:<span class="keyword">self</span> attribute:<span class="built_in">NSLayoutAttributeCenterY</span> multiplier:<span class="number">1</span> constant:<span class="number">0</span>];</div><div class="line"> [<span class="keyword">self</span> addConstraint:_labelCenterYConstraints];</div><div class="line"> label.text = @”I Am truly awesome!”;</div><div class="line"> …</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)updateConstraints &#123;</div><div class="line">  <span class="keyword">self</span>.labelCenterYConstraints.constant = <span class="keyword">self</span>.labelVerticalDisplacement;</div><div class="line">  [<span class="keyword">super</span> updateConstraints];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后在需要的地方：<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">awesome.labelVerticalDisplacement = <span class="number">40</span><span class="comment">;</span></div><div class="line">[awesome setNeedsUpdateConstraints]<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p>调用<code>setNeedsUpdateConstraints</code>会使autoLayout重新计算布局，因此会调用<em> updateConstraints</em>，从而读取新的label状态并更新约束。</p>
<p>在上面的例子中，你本可以只更新<em> _labelCenterYConstraints</em>这个约束，如果你的视图暴露出约束，或者如果你可以简单获得一个约束，那就直接设置约束的常量好了，不必使用<em>updateConstraints</em>。所以，上面的代码也可以这么实现：<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">awesome.labelCenterYConstraints.constant = <span class="number">40</span><span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p>一个<strong>非常糟糕</strong>的<em> updateConstraints</em>的实现会长这个样子：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)updateConstraints &#123;</div><div class="line">  [<span class="keyword">self</span> removeConstraints:<span class="keyword">self</span>.constraints];</div><div class="line">  <span class="comment">/*</span></div><div class="line">  create the constraint here</div><div class="line">  */</div><div class="line">  [<span class="keyword">super</span> updateConstraints];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这么做是非常错误的，因为：</p>
<ul>
<li>系统调用<em> updateConstraints</em>很多次，因此移除或者重新创建可能会校验约束的合理性。</li>
<li><code>[self removeConstraints:self.constraints]</code>; 会移除包括xib或storyboard创建的所有约束条件，你该怎么重新创建这些约束？（赶紧说你不能！）</li>
<li>上面的<em>updateConstraints</em>实现会覆盖掉<em>intrinsicContentSize</em>的效果，因为你在调用<code>[super updateConstraints];</code>后移除了系统添加的约束条件。</li>
<li><code>updateConstraints</code>应该被用来创建约束条件一次，然后仅仅移除掉失效的约束。它绝不该是一个移除所有约束再把每个传过来的布局添加上的地方。（感谢Alexis提供以下补充。）</li>
</ul>
<p>正确的实现方式是这样：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)updateConstraints &#123;</div><div class="line">  <span class="keyword">if</span> (!didSetConstraints) &#123;</div><div class="line"> didSetConstraints = <span class="literal">YES</span>;</div><div class="line">  <span class="comment">//create the constraint here</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//Update the constraints if needed</span></div><div class="line">  [<span class="keyword">super</span> updateConstraints];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在上面的代码中，创建约束的动作只会执行一次，然后在接下来的<em>updateConstraints</em>调用中，只会对这些已创建的约束的常量进行修改。</p>
<p>我一直在追寻真理！所以如果你有很多更好的实践经验，请在twitter上和我分享。</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2015/12/11/be-an-independent-explorer-not-a-lazy-coder/">Be an independent explorer, not a lazy coder</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2015-12-11
        </span></div>
    </header>

    <div class="post-content"><p>Here’s an SOF <a href="http://stackoverflow.com/a/18837736/1594792" title="http://stackoverflow.com/a/18837736/1594792" target="_blank" rel="external">answer</a> that makes me think.</p>
<p>Obviously, the asker required for the method of <em>simple code</em> of <a href="https://github.com/enormego/EGOCache" title="https://github.com/enormego/EGOCache" target="_blank" rel="external">EGOCache</a>  Library, since its responser didn’t provide any example or demo for it.</p>
<p>Two answers provided are very interesting. One gives line-by-line code —- who can refuse attractive and brief code? While the other one just tells you how to dive your head first and find out on your own.</p>
<p>It says as below.</p>
<blockquote>
<p>In the Objective-C world in a case like this when there isn’t as much documentation as I think there <em>should</em> be, I go straight to the header file. Then in your case I would look for a method named something like <code>setData</code> (I assumed this name even before I had read the header to answer this) which is here. Then you would use <code>dataForKey:</code> from here and finally <code>clearCache</code> from here so in short, yep your assumptions looked correct.</p>
<p>Give a man a fish, and you feed him for a day.</p>
</blockquote>
<p>It seems that we are gradually doted by the <em>Step-By-Step</em> tutorials and lose our independence to have a try. Of course, the tutorials are so friendly and helpful to fresh fish, meanwhile, they also make developers lazier.</p>
<p>In my aspect, developers are meant that you dare to explore spaces even unfamiliar to them, get down to issues, and grow up steadily even compared with yourself several days before. </p>
<p>Or else, you’re just a lazy coder.</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2015/12/09/checklist-for-renaming-an-iOS-project-totally/">Checklist for renaming an iOS project totally</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2015-12-09
        </span></div>
    </header>

    <div class="post-content"><h4 id="Checklist"><a href="#Checklist" class="headerlink" title="Checklist:"></a>Checklist:</h4><ul>
<li>Project name：<ol>
<li>Select your project in the project navigator, then select your project again in the project editor.</li>
<li>Choose View > Utilities > Show File Inspector.</li>
<li>In the file inspector, in the Identity and Type area, enter the new project name in the Name field.</li>
<li>Press Enter.</li>
<li>Click Rename to perform the rename operation.</li>
</ol>
</li>
<li>Project folder name.</li>
<li>Pod install/update.</li>
<li>Project name > Targets > Build Settings, search for your old project name.</li>
<li>PCH file.</li>
<li>Class annotation and category name.</li>
</ul>
<hr>
<p><strong>Ref:</strong></p>
<p><a href="https://developer.apple.com/library/mac/recipes/xcode_help-project_editor/RenamingaProject/RenamingaProject.html" target="_blank" rel="external">https://developer.apple.com/library/mac/recipes/xcode_help-project_editor/RenamingaProject/RenamingaProject.html</a></p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2015/12/01/auto-compile-and-package/">项目自动编译及打包</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2015-12-01
        </span></div>
    </header>

    <div class="post-content"><p>每到项目提测之后，就需要几乎天天打包ipa上传到ftp上去，大体步骤如下：<br>1.在Xcode中将代码编译打包为ipa，并重命名为***-currentDateTime.ipa；<br>2.打开FileZilla，连接到服务器上的ftp；<br>3.下载已有的plist文件到本地，更改其中的小版本号；<br>4.删除ftp上已有的***_test.ipa文件和***_test.plst文件；<br>5.将本地打包好的***_test.ipa文件和更改后的plist文件上传；<br>6.关闭FileZilla。</p>
<p>好麻烦。。。</p>
<p>简直是浪费时间。所以，为什么不写段代码替我做这些无聊的事呢？至少可以每天留出品尝一杯咖啡的时间。</p>
<p>Let’s move.</p>
<hr>
<h4 id="编译Build"><a href="#编译Build" class="headerlink" title="编译Build"></a>编译Build</h4><p>Xcode提供了命令行build的命令，即xcodebuild。可以通过<code>man xcodebuild</code>查看该命令的所有详细说明，也可以用<code>xcodebuild -usage</code>查看所有的可用参数。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcodebuild -workspace YourProject.xcworkspace -scheme YourProject -configuration <span class="string">"Release"</span> -destination generic/<span class="attribute">platform</span>=iOS #build <span class="attribute">BUILD_DIR</span>=<span class="string">"<span class="variable">$BUILD_DIR</span>"</span> <span class="attribute">BUILD_ROOT</span>=<span class="string">"<span class="variable">$BUILD_ROOT</span>"</span></div></pre></td></tr></table></figure></p>
<p>这里特别说明下<code>-destination</code>这个参数。如果要指定运行在某一个已连接设备，需要使用<code>iOS</code>选项。它支持<code>id</code>和<code>name</code>两个key，二者任取其一。<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">xcodebuild \</div><div class="line">  -<span class="ruby">workspace YourProject.xcworkspace \</span></div><div class="line">  -<span class="ruby">scheme MyApp \</span></div><div class="line">  -<span class="ruby">destination <span class="string">"platform=iOS,name=Gio's iPhone"</span> \</span></div><div class="line">  clean test</div><div class="line"></div><div class="line">xcodebuild \</div><div class="line">  -<span class="ruby">workspace YourProject.xcworkspace \</span></div><div class="line">  -<span class="ruby">scheme MyApp \</span></div><div class="line">  -<span class="ruby">destination <span class="string">'platform=iOS,id=YOUR_PHONE_UUID'</span> \</span></div><div class="line">  clean test</div></pre></td></tr></table></figure></p>
<p>同理，运行在模拟器中也是类似。更多详情见<a href="http://www.mokacoding.com/blog/xcodebuild-destination-options/" target="_blank" rel="external">这里</a>。由于我的使用场景通常是用企业账号来打包上传、供测试使用，所以这里使用的是<code>-destination generic/platform=iOS</code>，并不指定某一确切设备。</p>
<h4 id="打包成ipa"><a href="#打包成ipa" class="headerlink" title="打包成ipa"></a>打包成ipa</h4><p>上一步build后生成了YourProject.app文件，可以用xcrun来将其打包成ipa。<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">xcrun</span> -sdk iphoneos PackageApplication -v <span class="string">"<span class="variable">$APP_PATH</span>"</span> -o <span class="string">"<span class="variable">$IPA_PATH</span>"</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>这里补充一个小的知识点：.app和.ipa的差别：<br>.app是应用程序包。它包括可执行文件、Info.plist文件、图标、launch图片和一些其他应用程序资源。应用程序包是最终安装在设备上的部分。<br>.ipa是对.app应用程序包和一些只是为了供iTunes使用的文件（比如iTunesArtwork）的归档。</p>
</blockquote>
<p>另外，这里有一个需要注意的地方，xcrun需要<strong>绝对路径</strong>，相对路径是不管用的，会报类似这样的错：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun fails with <span class="keyword">zip</span> I/O <span class="keyword">error</span>: <span class="keyword">No</span> such <span class="keyword">file</span> or directory <span class="keyword">zip</span> <span class="keyword">error</span>:…</div></pre></td></tr></table></figure></p>
<p>你可以用<code>$pwd/YourProject</code>来获取。</p>
<h4 id="重命名ipa"><a href="#重命名ipa" class="headerlink" title="重命名ipa"></a>重命名ipa</h4><p>如果每次打包的ipa都是同样的名字，估计你很快就会分不清哪个版本是哪个版本，所以将ipa重命名添加上打包时间不失为一个不错的选择。<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">BUILD_DATETIME=<span class="string">"$(date +%Y%m%d%H%M%S)"</span></div><div class="line">mv $IPA_PATH <span class="string">"$BUILD_DIR/$BUILD_CONFIG-iphoneos/$TARGET_NAME-$BUILD_DATETIME.ipa"</span></div></pre></td></tr></table></figure></p>
<p>到此为止，需要上传到ftp的ipa已经准备好了。详细代码在<a href="https://github.com/CaliosD/xcode_tool/blob/master/build_n_package.sh" target="_blank" rel="external">这里</a>：。接下来的一篇，就要开始上传啦～</p>
<hr>
<p><strong>Ref:</strong></p>
<ul>
<li><a href="http://www.mokacoding.com/blog/xcodebuild-destination-options/" target="_blank" rel="external">Xcodebuild Destination Cheatsheet</a></li>
<li><a href="http://stackoverflow.com/questions/2949916/what-is-different-betwen-ipa-and-app-format-in-using-iphone" target="_blank" rel="external">what is different betwen .ipa and .app format in using iphone?</a></li>
<li><a href="http://stackoverflow.com/questions/25415333/xcrun-fails-with-zip-i-o-error-no-such-file-or-directory-zip-error" target="_blank" rel="external">xcrun fails with zip I/O error: No such file or directory zip error</a></li>
<li><a href="http://blog.devtang.com/blog/2012/02/16/apply-daily-build-in-ios-project/" target="_blank" rel="external">给iOS工程增加Daily Build</a></li>
<li><a href="http://stackoverflow.com/questions/20551566/display-current-date-and-time-without-punctuation" target="_blank" rel="external">Display current date and time without punctuation</a></li>
<li><a href="http://objccn.io/issue-17-2/" target="_blank" rel="external">代码签名探析</a></li>
</ul>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2015/11/26/how-not-to-crash-6-properties-and-accessories/">【译】如何避免程序崩溃-6：属性和存取器</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2015-11-26
        </span></div>
    </header>

    <div class="post-content"><p>原文链接：<a href="http://inessential.com/2015/05/27/how_not_to_crash_6_properties_and_acce" target="_blank" rel="external">http://inessential.com/2015/05/27/how_not_to_crash_6_properties_and_acce</a></p>
<hr>
<p>这个东西让我有点发怵：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-<span class="ruby"> (void)someRandomMethod &#123;</span></div><div class="line">  some stuff…</div><div class="line">  _thing = otherThing;</div><div class="line">  other stuff…</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>你可以证明这是正确的。你使用ARC，所以属性retain和release的计数会自动增减。又没有人在观察<code>_thing</code>。</p>
<p>好吧。它是合法的，也是管用的。</p>
<p>假设你发现那个thing应该是可观察的。所以每处设置thing的值，你都会添加调用的方法：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="section">[self willChangeValueForKey:kThingKey]</span><span class="comment">;</span></div><div class="line"><span class="attr">_thing</span> = otherThing;</div><div class="line"><span class="section">[self didChangeValueForKey:kThingKey]</span><span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p>也是合法的，也管用。</p>
<p>即将出现的问题是：以后，比如明天，或者六个月之后，你或者其他人给thing写了个自定义的setter —— 可能是因为你需要在设置thing的时候添加类似<code>self.needsDisplay = YES</code>这样的东西 —— 然后你就出现了一个bug，无论何时thing的改变都不会让view重新绘制。</p>
<p>或者更糟糕：可能未来的自定义setter打破了一个观察者，并在thing改变的时候添加一个新的。由于你是直接设置_thing的，观察模式不会正确的保留，然后你就崩溃了。</p>
<p>答案是遵循一个简单的规则：<strong>在set或get属性的时候，使用存取器。</strong></p>
<p>换句话说，这么写：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">－ (<span class="literal">void</span>)someRandomMethod &#123;</div><div class="line">  some stuff…</div><div class="line">  <span class="built_in">self</span>.thing = otherThing;</div><div class="line">  other stuff…</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不管你是否自定义setter，这么写都管用。当你设置thing的时候，就不用这也担心那也管了。</p>
<p>（这里是一个编程规则的简单测试：如果你遵循它就不会犯错，但是<em>不</em>遵循它就<em>可能</em>犯错，那你最好还是遵循它。）</p>
<p>（不要担心使用存取器引起的性能问题。我是一个性能推崇者，而我从未发现这样会引起问题。如果你的app出现了性能问题，剖析一下，找到真正的原因。）</p>
<h4 id="例外"><a href="#例外" class="headerlink" title="例外"></a>例外</h4><p>有四个地方你 <em>不</em> 应该使用存取器：<strong>init方法，dealloc，自定义的getter和自定义getter。</strong> 这样可以避免副作用。</p>
<p>如果你 <em>需要</em> <strong>副作用</strong> —— 比如说，在dealloc中移除观察者 —— 就是那些通常放在setter中的部分，可以把它放在单独的方法里，然后从setter和dealloc中调用它。（也要考虑到在init和dealloc之外添加和移除观察者可能意味着你的代码需要重构。）</p>
<blockquote>
<p>译者注：函数副作用指当调用函数时，除了返回函数值之外，还对主调用函数产生附加的影响。例如修改全局变量（函数外的变量）或修改参数。</p>
</blockquote>
<h4 id="自动合成"><a href="#自动合成" class="headerlink" title="自动合成"></a>自动合成</h4><p>千万不要创建实例变量。而要声明属性。</p>
<p>属性会自动合成实例变量。只有当Xcode告诉你你需要的时候再用<code>@synthesize</code>。</p>
<h4 id="使用ARC"><a href="#使用ARC" class="headerlink" title="使用ARC"></a>使用ARC</h4><p>如果你有非ARC的代码，把它更新到ARC吧。手动管理内存是极易犯错的。即使是有多年经验的人也会一次次的犯错，而错误会导致崩溃（或者好一点，导致内存泄漏或内存被遗弃）。</p>
<p>通常情况下，我并不主张对于运行良好的代码进行编辑 —— 但是如果你有需要维护的代码，那就帮自己也帮同伴一个忙，把它转化成ARC吧。（随着时间推移，每个人都会在手动内存管理的路上越走越糟。而成为这样的英雄也不会有任何加分。）</p>
<p>（可能使用ARC会让你陷入性能问题，特别是当你在处理loop中的大量对象时。记得使用自动释放池。别轻易下断言：用分析器说话。）</p>
<p>（同时：ARC转换器可能不会总是如你所愿。如果你使用它的话，检查它改变的地方。记住每次转化一个文件。Target可以允许ARC和非ARC同时存在。）</p>
<h4 id="不要用-这个"><a href="#不要用-这个" class="headerlink" title="不要用 -> 这个"></a>不要用 -> 这个</h4><p>这个曾让我神经崩溃：thing->property。别这么干。</p>
<h4 id="dealloc"><a href="#dealloc" class="headerlink" title="dealloc"></a>dealloc</h4><p>如果你不需要dealloc（由于使用ARC），那就不要写它。没必要在dealloc中把属性设置为nil。</p>
<p>delegate是个明显的特例：把delegate置为空。</p>
<h4 id="使用weak"><a href="#使用weak" class="headerlink" title="使用weak"></a>使用weak</h4><p>Weak太棒了。比如，delegate就应该是weak。</p>
<p>父类应该持有它们的子类，但是子类应该持有它们父类的弱引用（如果存在引用的话）。设置weak会让你避开那些<a href="http://www.caliosd.gq/2015/11/12/how-not-to-crash-1-kvo-and-manual-bind/" title="http://www.caliosd.gq/2015/11/12/how-not-to-crash-1-kvo-and-manual-bind/">用来解除循环引用的invalidate方法</a>。</p>
<p>无论在任何情况下都不要使用unsafe_unretained。那是个陷阱。你可能也会这么写：</p>
<figure class="highlight puppet"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">define</span> <span class="section">CRASHING_BUG</span> unsafe_unretained</div></pre></td></tr></table></figure>
<p>顾名思义，它叫做<em>不安全</em>。</p>
<p>不要带着剪刀跑。嘿 —— 甚至不要碰那些剪刀。剪刀有毒。</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2015/11/26/how-not-to-crash-5-threading-part-2/">【译】如何避免程序崩溃-5：线程（二）</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2015-11-26
        </span></div>
    </header>

    <div class="post-content"><p>原文链接：<a href="http://inessential.com/2015/05/26/how_not_to_crash_5_threading_part_2" target="_blank" rel="external">http://inessential.com/2015/05/26/how_not_to_crash_5_threading_part_2</a></p>
<hr>
<p>我<a href="http://www.caliosd.gq/2015/11/19/how-not-to-crash-4-threading/">上一篇关于线程</a>的文章留下来一个开放的问题：在主线程以外的代码是如何交流的，又如何 —— 安全地 —— 返回主线程。</p>
<p>哪个对象创造后台任务，哪个对象就处理相应的结果。这是硬性规定。</p>
<blockquote>
<p>译者注：谁污染，谁治理。这个原则适用于ARC，也适用于多线程。</p>
</blockquote>
<p>通常创建任务的对象都是持续在整个app生命周期中的。一个例子可能是图片缓存，缓存可能会在app的生命周期中被清空，但是缓存对象是一直存在的。</p>
<p>另一个例子：比如说Vesper有一个VSAccount对象。<em>一直</em> 都只有一个VSAccount对象。用户可能有也可能没有服务器的账号。他们可以选择使用哪个服务器的账号。但是只有唯一的VSAccount对象持续于整个app的生命周期。</p>
<p>(<strong>注意</strong>：显然，一个管理多个账户的应用会做一些不同的处理。但是Vesper最多管理一个服务器账户，所以这样做还不错。在Vesper的例子中，多个账户会遵守<strong>YAGNI</strong>规则。)</p>
<blockquote>
<p>译者注：YAGNI，即You Ain’t Gonna Need It，适可为止原则，指的是只需要将应用程序必需的功能包含进来，而不要试图添加任何其他你认为可能需要的功能。</p>
</blockquote>
<p>VSAccount对象负责向服务器发送http请求，处理返回的结果。它会在后台队列中把JSON转化成中间对象。</p>
<p>它通过NSData-to-process和一个回调block来调用JSON处理器。当处理器结束的时候，它会在主线程调用block：</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (callback) &#123;</div><div class="line">  dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">	  callback(parsedObjects)</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这对于我来说是一个如此常用的模式 —— 在主线程上调用需要一个参数的block —— 以至于我为它写了一个通用方法。JSON处理器的确就是做了这样的事情：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BSCallBlockWithParameter(<span class="name">callback</span>, parsedObjects)<span class="comment">;</span></div></pre></td></tr></table></figure>
<p><code>BSCallBlockWithParameter</code>长这个样子：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if (!callback)</div><div class="line">  return<span class="comment">;</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">dispatch_async(dispatch_get_main_queue(), </span>^&#123;</div><div class="line">  callback(parsedObjects)<span class="comment">;</span></div><div class="line">&#125;)<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>我一直用这个。非常方便。</p>
<h4 id="使用这种方法的关键"><a href="#使用这种方法的关键" class="headerlink" title="使用这种方法的关键"></a>使用这种方法的关键</h4><p>我从来都不想担心创建后台任务的对象会不翼而飞，所以我只通过延续在app整个生命周期的对象创建后台任务。</p>
<p>你肯定也不想面临任务完成并回调之前、创建后台任务的对象不翼而飞的状况（或者部分或彻底分崩离析）。这是个潜在的复杂问题，我甚至不想去考虑它。（对于初学者而言，我<em>讨厌</em><code>weak-self</code>满天飞。）</p>
<p>这也正是你在写不会崩溃的代码时需要具备的心态：事情一旦是复杂的，那么它就是易出错的。想办法让它异常简单。</p>
<p>（你可能会举出复杂的例子，并且证明它的正确性 —— 但是以后你会不会有所质疑、觉得这样的代码需要验证？如果你稍有偏差它是不是就会挂掉？如果其他人使用它呢？）</p>
<p>所以，我用简单的办法解决问题：使用不会被释放的对象。</p>
<p>但是有一个需要谨记及避免的事：回调block可以安全地调用类方法和C语言函数。如果实例消失的话，实例方法就是不安全的 —— 但是类方法和C语言函数理论上是可以安全调用的。</p>
<p>我不经常使用这个知识点，但是我会不断的发现它的确有用。要么谨慎点使用它，要么干脆不用。</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2015/11/25/load-class-from-storyboard-in-code/">通过代码加载storyboard中的class</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2015-11-25
        </span></div>
    </header>

    <div class="post-content"><p>1.在attribute inspector中给要加载的view controller添加identifier；</p>
<p><img src="http://i12.tietuku.com/b2e09019a0d77401.png" alt=""></p>
<p>2.添加如下代码：</p>
<pre><code>UIStoryboard *storyboard = [UIStoryboard storyboardWithName:@&quot;MainStoryboard&quot; bundle:nil];
DetailViewController *detailViewController = [storyboard instantiateViewControllerWithIdentifier:@&quot;DetailViewController&quot;];
[self.navigationController pushViewController:detailViewController animated:YES];
</code></pre>
        </div></article>
      <nav class="pagination"><a class="prev" href="/page/7/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text">Prev</span>
      </a>
    <a class="next" href="/page/9/">
        <span class="next-text">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></section></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:calios_1124@163.com" class="iconfont icon-email" title="email"></a>
        <a href="http://github.com/caliosd" class="iconfont icon-github" title="github"></a>
        <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">&copy;2015 - 2019<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Calios</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>
</html>
